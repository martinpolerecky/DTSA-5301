---
title: 'Covid 19 John Hopkins'
output: pdf_document
---

```{r}
knitr::opts_chunk$set(echo = TRUE)
library(formatR)
library(tidyverse)
library(lubridate)
```

We are going to be looking at COVID 19 cases using the John Hopkins data set in the US to see if there is a state that can be used as a predictor for other states. 
We're going to change the columns for each date into a row for each date with the new column value being number of cases. 
We'll also remote state location information since we don't need that and reformat the date field into a date datatype. 

```{r}
url_in <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/"
file_names <- c("time_series_covid19_confirmed_US.csv",
                "time_series_covid19_deaths_US.csv")
urls <- str_c(url_in, file_names)

US_cases <- read_csv(urls[1])
US_deaths <- read_csv(urls[2])
US_cases <- US_cases %>% pivot_longer(cols = -(UID:Combined_Key), names_to = "date", values_to = "cases") %>% select(Admin2:cases) %>% mutate(date = mdy(date)) %>% select(-c(Lat, Long_))
US_deaths <- US_deaths %>% pivot_longer(cols = -(UID:Population), names_to = "date", values_to = "deaths") %>% select(Admin2:deaths) %>% mutate(date = mdy(date)) %>% select(-c(Lat, Long_))
US <- US_cases %>% full_join(US_deaths)
summary(US)
```

Instead of having the data broken down by county, we'll add up the counties together to get data for the whole state.
Also, if there were rows with 0 cases, they will be filtered out.
The visualization shows deaths and cases over time (x axes being the date and y axis being the # of cases/deaths).

```{r}
US_by_state <- US %>% group_by(Province_State, Country_Region, date) %>% summarize(cases = sum(cases), deaths = sum(deaths), Population = sum(Population)) %>% mutate(deaths_per_mill = deaths * 1000000 / Population) %>% select(Province_State, Country_Region, date, cases, deaths, deaths_per_mill, Population) %>% ungroup()
US_totals <- US_by_state %>% group_by(Country_Region, date) %>% summarize(cases = sum(cases), deaths = sum(deaths), Population = sum(Population)) %>% mutate(deaths_per_mill = deaths * 1000000 / Population) %>% select(Country_Region, date, cases, deaths, deaths_per_mill, Population) %>% ungroup()
US_totals %>% filter(cases > 0) %>% ggplot(aes(x = date, y = cases)) + geom_line(aes(color = "cases")) + geom_point(aes(color = "cases")) + geom_line(aes(y = deaths, color = "deaths")) + geom_point(aes(y = deaths, color = "deaths")) + scale_y_log10() + theme(legend.position = "bottom", axis.text.x = element_text(angle = 90)) + labs(title = "COVID19 in US", y = NULL)
```

There are some new fields in the snippet below, notably day to day change (using the lag function) and cases/deaths per thousand.
Our new model will predict deaths per thousand (US_w_pred) based on cases per thousand using linear regression. Red color is the predicted outcome whereas blue represents the actual data.

```{r}
US_by_state <- US_by_state %>% mutate(new_cases = cases - lag(cases), new_deaths = deaths - lag(deaths), cases_per_thou = cases * 1000 / Population, deaths_per_thou = deaths * 1000 / Population) %>% filter(cases > 0, Population > 0)
summary(US_by_state)

mod <- lm(deaths_per_thou ~ cases_per_thou, data = US_by_state)
summary(mod)
US_w_pred <- US_by_state %>% mutate(pred = predict(mod))
US_w_pred %>% ggplot() + geom_point(aes(x = cases_per_thou, y = deaths_per_thou), color = "blue") + geom_point(aes(x = cases_per_thou, y = pred), color = "red")
```

## Analysis
Next up: analyses of individual US states.
For each state a linear model is created predicting the deaths based on cases per thousand.
The second for loop also clusters states by models.

```{r}
options(warn=-1)
States <- split(US_by_state, US_by_state$Province_State)
for(i in 1:length(States)){
  States[i][[1]] <- States[i][[1]] %>% mutate(cases_per_thou = as.numeric(cases_per_thou)) %>% mutate(deaths_per_thou = as.numeric(deaths_per_thou))
}

models = c()
states = c()
corrs = c()

for(state in States){
  m <- lm(deaths_per_thou ~ cases_per_thou, data = state)
  name <- state$Province_State[1]
  for(sstate in States){
    this_s <- predict(m, sstate)
    c <- cor(sstate$deaths_per_thou, this_s)
    models <- append(models, name)
    states <- append(states, sstate$Province_State[1])
    corrs <- append(corrs, c)
  }
}
results <- tibble(Model=models, State=states, Corr=corrs)
summary(results)
```

We're now going to make predictor sets of states based on their correlations in the previous analysis (using while loop until all states are assigned to a set).
The sets are created based on the highest correlation first and, if necessary, with the next highest correlation.
We will also need to add the special case for when a state has no correlating model (in this case, it's a state with no deaths) where it will be added to it's own unique set. 

```{r}
sets <- tibble(State = unique(states), Set = 0)
count <- 1
while(dim(results) != c(0,3)){
  next_match <- results %>% slice_max(order_by = Corr)
  if(dim(next_match) == c(0,3)){
    next_match <- results %>% slice(1)
    sets <- rows_update(sets, tibble(State = next_match$State, Set = count))
    count <- count + 1
    results <- results %>% filter(State != next_match$State)
    next
  }
  else{
    next_match <- next_match %>% slice(1)
  }
  idx <- sets %>% filter(State == next_match$Model)
  if(idx$Set == 0){
    sets <- rows_update(sets, tibble(State = next_match$Model, Set = count))
    sets <- rows_update(sets, tibble(State = next_match$State, Set = count))
    count <- count + 1
    results <- results %>% filter(State != next_match$State) %>% filter(State != next_match$Model)
  }
  else{
    sets <- rows_update(sets, tibble(State = next_match$State, Set = idx$Set))
    results <- results %>% filter(State != next_match$State)
  }
}
```

Finally, let's visualize the results of state grouping process used previously. 
The idea is to observe the relationship between cases and deaths within each set.

```{r}
for(i in 1:(count-1)){
  curr_set <- sets %>% filter(Set == i) %>% select(State)
  cat(str_c("Group ", as.character(i), ":\n"))
  cat(curr_set$State, sep="\n")
  cat("\n")
  curr_data <- curr_data <- US_by_state %>% filter(Province_State %in% curr_set$State)
  print(ggplot(curr_data, aes(x = cases_per_thou, y = deaths_per_thou, color= Province_State))+geom_point())
}

options(warn=1)
```

## Summary
Some of the groups (2,3,4,7,9..) seem to be well clustered whereas group 5 appears to be more disperse. Groups 1,11,13 and 14 are somewhere in between.
Groups 6 and 8 are very divergent, which could possibly be rectified by using a cut-off value. As there were no deaths for group 17 in the dataset, it has no correlating models. 
To address the correlation bias, we could either introduce a cut-off value as mentioned before, or we could calculate how the state which is about to be added to a set compares to 
the other states in the set. This should prevent outliers to some degree.
To conclude, the clustering algorithm for predicting Covid-19 deaths in sets of states worked for the most part, aside from a few outliers with poor correlation.
